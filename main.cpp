// ========================================
// HARIYA DISTRIBUTED KV SERVER - DEBUG VERSION OF MAIN
// ========================================

#include "hariya_server.h"
#include "cluster_config.h"
#include <iostream>
#include <csignal>
#include <memory>

// Global server instance for signal handling
std::unique_ptr<HariyaServer> g_server;

// Signal handler for graceful shutdown
void signalHandler(int signal) {
    std::cout << "\nðŸ›‘ Received signal " << signal << ", shutting down gracefully..." << std::endl;
    if (g_server) {
        g_server->stop();
    }
    exit(0);
}

// Print usage information
void printUsage(const char* program_name) {
    std::cout << "Usage: " << program_name << " [port] [wal_file] [node_id] [hostname]" << std::endl;
    std::cout << "  port      - Port number to listen on (default: 6379)" << std::endl;
    std::cout << "  wal_file  - Path to WAL file (default: data/hariya.wal)" << std::endl;
    std::cout << "  node_id   - Unique node ID (default: autogenerated)" << std::endl;
    std::cout << "  hostname  - Hostname or IP (default: 127.0.0.1)" << std::endl;
    std::cout << std::endl;
    std::cout << "Examples:" << std::endl;
    std::cout << "  " << program_name << "                    # Use defaults" << std::endl;
    std::cout << "  " << program_name << " 8080               # Custom port" << std::endl;
    std::cout << "  " << program_name << " 8080 my.wal        # Custom port and WAL file" << std::endl;
    std::cout << "  " << program_name << " 8080 my.wal node1  # Custom port, WAL, node ID" << std::endl;
    std::cout << "  " << program_name << " 8080 my.wal node1 192.168.1.10 # All custom" << std::endl;
}

int main(int argc, char* argv[]) {
    // Default configuration
    int port = 6379;
    std::string wal_file = "data/hariya.wal";
    std::string nodeId = "";
    std::string hostname = "127.0.0.1";
    
    std::cout << "ðŸ› DEBUG: main() started with " << argc << " arguments" << std::endl;
    for (int i = 0; i < argc; i++) {
        std::cout << "   argv[" << i << "] = " << argv[i] << std::endl;
    }
    
    // Parse command line arguments
    if (argc > 1) {
        if (std::string(argv[1]) == "--help" || std::string(argv[1]) == "-h") {
            printUsage(argv[0]);
            return 0;
        }
        try {
            port = std::stoi(argv[1]);
            if (port < 1 || port > 65535) {
                std::cerr << "âŒ Error: Port must be between 1 and 65535" << std::endl;
                return 1;
            }
        } catch (const std::exception& e) {
            std::cerr << "âŒ Error: Invalid port number '" << argv[1] << "'" << std::endl;
            printUsage(argv[0]);
            return 1;
        }
    }
    if (argc > 2) wal_file = argv[2];
    if (argc > 3) nodeId = argv[3];
    if (argc > 4) hostname = argv[4];
    // Defer cluster join until after server is constructed
    std::vector<std::string> cluster_nodes;
    bool join_cluster = false;
    std::string boot_host, boot_port;
    if (argc > 5) {
        std::string bootstrap = argv[5];  // Format: host:port
        if (bootstrap != "--standalone") {
            size_t colon = bootstrap.find(':');
            if (colon != std::string::npos) {
                std::string boot_host = bootstrap.substr(0, colon);
                std::string boot_port = bootstrap.substr(colon + 1);
                cluster_nodes = { boot_host + ":" + boot_port };
                join_cluster = true;
                std::cout << "ðŸ”„ Will join cluster via bootstrap node: " 
                      << boot_host << ":" << boot_port << std::endl;
            }
        }
    }

    std::cout << "ðŸ› DEBUG: Parsed arguments:" << std::endl;
    std::cout << "   port = " << port << std::endl;
    std::cout << "   wal_file = " << wal_file << std::endl;
    std::cout << "   nodeId = " << nodeId << std::endl;
    std::cout << "   hostname = " << hostname << std::endl;

    // Print startup banner
    std::cout << "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”" << std::endl;
    std::cout << "â”‚    ðŸŒ HARIYA DISTRIBUTED KV SERVER ðŸŒ       â”‚" << std::endl;
    std::cout << "â”‚   Redis-like Distributed Cache & Cluster     â”‚" << std::endl;
    std::cout << "â”‚           Version 2.0 (Cluster)              â”‚" << std::endl;
    std::cout << "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜" << std::endl;
    std::cout << std::endl;

    // Print configuration
    std::cout << "ðŸ”§ Configuration:" << std::endl;
    std::cout << "   ðŸ“¡ Port: " << port << std::endl;
    std::cout << "   ðŸ’¾ WAL File: " << wal_file << std::endl;
    std::cout << "   ðŸ†” Node ID: " << (nodeId.empty() ? "(auto)" : nodeId) << std::endl;
    std::cout << "   ðŸ–¥ï¸  Hostname: " << hostname << std::endl;
    std::cout << std::endl;

    // Setup signal handlers for graceful shutdown
    std::cout << "ðŸ› DEBUG: Setting up signal handlers..." << std::endl;
    signal(SIGINT, signalHandler);   // Ctrl+C
    signal(SIGTERM, signalHandler);  // Termination request
    signal(SIGQUIT, signalHandler);  // Quit request
    #ifndef _WIN32
    signal(SIGPIPE, SIG_IGN);        // Ignore broken pipe (client disconnect)
    #endif
    std::cout << "ðŸ› DEBUG: Signal handlers set up \n \n" << std::endl;

    try {
        std::cout << "ðŸ”§ Creating distributed server instance... \n \n" << std::endl;
        std::cout << "ðŸ› DEBUG: About to call HariyaServer constructor... \n \n" << std::endl;
        
        // Create distributed server
        g_server = std::make_unique<HariyaServer>(port, nodeId, hostname, wal_file);
        std::cout << "âœ… Server instance created successfully \n \n" << std::endl;
        std::cout << "ðŸ› DEBUG: HariyaServer constructor completed \n \n" << std::endl;
        
        // Add debug status before starting
        // Add debug status before starting
        std::cout << "ðŸ› DEBUG: Server status before start(): \n \n" << std::endl;
        g_server->debugStatus();

        // Join cluster if requested
        if (join_cluster) {
            g_server->joinCluster(cluster_nodes);
        }
        
        std::cout << "ðŸš€ Starting server on port " << port << "..." << std::endl;
        
        // Start the server (this should bind to port and listen)
        bool startResult = g_server->start();
        std::cout << "ðŸ› DEBUG: g_server->start() returned: " << (startResult ? "true" : "false") << std::endl;
        
        if (!startResult) {
            std::cerr << "âŒ Failed to start distributed server on port " << port << std::endl;
            std::cerr << "ðŸ’¡ Common issues:" << std::endl;
            std::cerr << "   - Port " << port << " might be in use (try: sudo netstat -tlnp | grep " << port << ")" << std::endl;
            std::cerr << "   - Permission denied for port < 1024 (try port > 1024 or run as root)" << std::endl;
            std::cerr << "   - Firewall blocking the port" << std::endl;
            
            // Add debug status after failed start
            std::cout << "ðŸ› DEBUG: Server status after failed start():" << std::endl;
            g_server->debugStatus();
            
            return 1;
        }
        
        std::cout << "âœ… Distributed server started successfully!" << std::endl;
        std::cout << "ðŸ› DEBUG: Server status after successful start():" << std::endl;
        g_server->debugStatus();
        
        std::cout << "ðŸŒ Ready for cluster operations and client connections" << std::endl;
        std::cout << "ðŸ”„ Press Ctrl+C to shutdown gracefully" << std::endl;
        std::cout << "ðŸ“ Test connection with: telnet localhost " << port << std::endl;
        std::cout << "=" << std::string(50, '=') << std::endl;

        // Run server (blocks until shutdown)
        std::cout << "ðŸƒ Starting main server loop..." << std::endl;
        std::cout << "ðŸ› DEBUG: About to call g_server->run()..." << std::endl;
        g_server->run();
        std::cout << "ðŸ› DEBUG: g_server->run() completed" << std::endl;

    } catch (const std::exception& e) {
        std::cerr << "âŒ Server error: " << e.what() << std::endl;
        std::cerr << "ðŸ” Stack trace or additional details may be available above" << std::endl;
        std::cout << "ðŸ› DEBUG: Exception caught in main" << std::endl;
        return 1;
    } catch (...) {
        std::cerr << "âŒ Unknown server error occurred" << std::endl;
        std::cout << "ðŸ› DEBUG: Unknown exception caught in main" << std::endl;
        return 1;
    }

    std::cout << "âœ… Server shutdown complete" << std::endl;
    std::cout << "ðŸ› DEBUG: main() ending normally" << std::endl;
    return 0;
}